---
layout: page
title: 'Java: Inheritance'
permalink: /java-inheritance/
date: 2015-01-01 19:59:08.000000000 -08:00
categories:
- java
tags: []
status: publish
type: page
published: true
meta:
  _wpcom_is_markdown: '1'
  _edit_last: '91'
  _wp_page_template: default
author:
  login: tomjohnson1492
  email: tomjohnson1492@gmail.com
  display_name: Tom Johnson
  first_name: Tom
  last_name: Johnson
excerpt: !ruby/object:Hpricot::Doc
  options: {}
---
<h2>Quick summary</h2>
<ul>
<li>allows you to create a subclass that inherits the properties (fields + methods) of its parent or superclass.</li>
<li>use the keyword <code>extends</code> to declare a subclass. (child extends parent).</li>
</ul>
<p>The following code demonstrates the principle of inheritance. Here we have a class that has 2 methods: start and stop. In the App.java file, where the main method is, we instantitate the class by creating an object from it, and then we call a couple of methods.</p>
<pre><code>public class Machine {

    public void start() {
     System.out.println("Machine started.");

    }
   public void stop() {
       System.out.println("Machine stopped.");
   }


}
</code></pre>
<p>If you go to the app.java class, we have this:</p>
<pre><code>public class App {

public static void main(String[] args) {
    Machine mach1 = new Machine();
    mach1.start();
    mach1.stop();
}

}
</code></pre>
<p>Now suppose we have another class called Car.</p>
<pre><code>public class Car extends Machine {

}
</code></pre>
<p>Now <code>Car</code> inherits all of <code>Machine</code>'s properties, including its methods. You can then use this in your main method:</p>
<pre><code>Car car1 = new Car();
car1.start();
car1.stop();
</code></pre>
<p>You could also add some more methods to Car that Machine doesn't have. This is the power of inheritance. A lot of times people may have access to use a class, but they won't have the ability to modify that class. In these cases, the user can extend the class by creating a new class that inherits its methods, and then add the methods or other properties that they need.</p>
<p>You can also overwrite methods. If you add a method in your Car class that has the same name as the Machine class that Car is extending, the Car's method will overwrite the machine method that has the same name.</p>
<p>You can also overwrite a method. In Eclipse, right click, select <strong>Source > Override/Implement Methods</strong>.</p>
<p>Then you end up with something like this:</p>
<pre><code>@Override
public void start() {
    // TODO Auto-generated method stub
    super.start();
}
</code></pre>
<p>The @Override note means that the method is being overwritten. The <code>super.start()</code> simply is a stub because until you overwrite the method, it's just referencing the parent's method. That's what the <code>super</code> is about -- it's the opposite of "sub."</p>
<p>The <code>@Override</code> is an annotation. Now this annotation will check that your override is actual a method that exists in the parent class. It enforces some rules there.</p>
<p>As for variables, let's say that you have this in Machine:</p>
<pre><code>private String name = "Machine Type 1";
</code></pre>
<p>Now in your subclass, suppose you try to use this variable in your subclass. What happens? Because the variable is marked as private in the parent class, it can't be inherited in the subclass. If you declare something <code>private</code>, it's only available within the class.</p>
<p>But if you remove the <code>private</code> access specifier, then other classes that are using that package can use the variable. If you change the access specifier to <code>protected</code>, it means that you can access it anywhere within the package and within any child class.</p>
<p>In general, don't override variables. Just override methods.</p>
